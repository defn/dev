repo ?=
push ?= --push
name ?= $(shell uname -n | cut -d. -f1 | tr A-Z a-z | perl -pe 's{-\d$$}{}')
k3d_name ?= $(name)
context ?= k3d-$(name)
podname ?= $(name)-0
control ?= $(shell echo $(name) | sed s/-0//)
domain ?= $(shell tailscale cert 2>&1 | grep 'For domain' | cut -d'"' -f2 | cut -d. -f2-)
node ?= k3d-control-server-0
n ?=
k ?=
r ?= bash

dummy_ip ?= 169.254.32.1

DEFN_DEV_HOST      ?= "k3d-$(name).${domain}"
DEFN_DEV_HOST_API  ?= "$${DEFN_DEV_HOST_API:-127.0.0.1}"
DEFN_DEV_HOST_PORT ?= "$${DEFN_DEV_HOST_PORT:-6443}"

first = $(word 1, $(subst -, ,$@))
second = $(word 2, $(subst -, ,$@))
first_ = $(word 1, $(subst _, ,$@))
second_ = $(word 2, $(subst _, ,$@))

trust-ca:
	sudo security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db etc/ca.crt

macos:
	-$(shell which gpg-agent) --daemon --pinentry-program $(which pinentry-mac)
	for ip in $(dummy_ip); do if ! ifconfig lo0 | grep "inet $$ip"; then sudo ifconfig lo0 alias "$$ip" netmask 255.255.255.255; fi; done;
	ifconfig lo0
	defaults write -g ApplePressAndHoldEnabled -bool false
	-$(MAKE) registry
	-docker context create host --docker host=unix:///var/run/docker.sock

symlinks:
	mark -- configure symlinks
	bash -x bin/persist-cache

perms:
	mark -- configure permissions
	if [[ "Linux" == "$(shell uname -s)" ]]; then if test -S /var/run/docker.sock; then sudo chgrp ubuntu /var/run/docker.sock; sudo chmod 770 /var/run/docker.sock; fi; fi
	if test -S /run/containerd/containerd.sock; then sudo chgrp ubuntu /run/containerd/containerd.sock; sudo chmod 770 /run/containerd/containerd.sock; fi
	-chmod 0700 ~/.gnupg/. ~/.gnupg2/.
	-if test -d ~/.password-store/home/.gnupg; then chmod 0700 ~/.password-store/home/.gnupg; fi
	-if ! test -f ~/.kube/config; then touch ~/.kube/config; fi
	-chmod 0600 ~/.kube/config

install:
	-$(MAKE) nix-$(shell uname -s)
	~/bin/de ~ $(MAKE) install-inner

install-inner:
	$(MAKE) symlinks perms

	mark -- configure password-store
	mkdir -p ~/work/password-store
	if test -n "$${GIT_AUTHOR_NAME:-}"; then \
		if ! test -d ~/work/password-store/.git/.; then \
			git clone https://github.com/$${GIT_AUTHOR_NAME}/password-store ~/work/password-store; \
		fi; \
	fi

	mark -- configure gpg
	if test -d ~/.password-store/home/.gnupg; then rsync -ia ~/.password-store/home/.gnupg/. ~/.gnupg/.; fi
	$(MAKE) perms
	env GPG_TTY=$$(tty) $(MAKE) init-gpg

	docker context create pod --docker host=tcp://localhost:2375 || true \
		&& docker context create host --docker host=unix:///var/run/docker.sock || true \
        && docker context use host

	mark -- configure repos

	if nc -z -v localhost 8200 2>/dev/null; then \
		$(MAKE) vault-unseal; \
		fi

	$(MAKE) login

	@env VAULT_ADDR="http://localhost:8200" VAULT_TOKEN="$$(pass Initial_Root_Token)" $(MAKE) manage

	mark -- dotfiles
	if test -n "$${GIT_AUTHOR_NAME:-}"; then \
		mkdir -p ~/.config/coderv2/dotfiles; \
		mkdir -p /home/ubuntu/work/.codespaces/.persistedshare; \
		rm -rf ~/work/.codespaces/.persistedshare/dotfiles; \
		ln -nfs ~/.config/coderv2/dotfiles ~/work/.codespaces/.persistedshare/dotfiles; \
		coder dotfiles --yes https://github.com/$${GIT_AUTHOR_NAME}/dotfiles; \
	fi

down:
	touch .local/share/code-server/idle

logout:
	-echo yes | gh auth logout --hostname github.com
	-argocd logout argocd-server.argocd.svc
	-echo RELOADAGENT | gpg-connect-agent

login:
	mark -- configure kubeconfig, argocd
	if test -f /run/secrets/kubernetes.io/serviceaccount/ca.crt; then $(MAKE) kubeconfig; $(MAKE) argocd-login || true; fi

	$(MAKE) login-site

manage:
	mark -- manage clusters

	for a in $$(env DOCKER_CONTEXT=host k3d cluster list 2>/dev/null | tail -n +2 | awk '{print $$1}'); do \
		argocd cluster add -y --upsert "k3d-$$a"; \
		control apply -f "app/e/k3d-$$a.yaml"; \
		if nc -z -v localhost 8200 2>/dev/null; then \
			env VAULT_ADDR="http://localhost:8200" VAULT_TOKEN="$$(pass Initial_Root_Token)" $(MAKE) vault-trust "k=k3d-$$a"; \
			"$$a" rollout restart deployment -n external-secrets external-secrets 2>/dev/null || true; \
			fi; \
		done

	$(MAKE) manage-site

github-login:
	if ! gh auth status; then echo Y | gh auth login -p https -h github.com -w; fi

argocd-login:
	if control get ns argocd 2>/dev/null; then \
	if ! argocd app list 2>/dev/null >/dev/null; then \
		argocd login --insecure argocd-server.argocd.svc --username admin --password adminadmin 2>/dev/null \
			|| (argocd login --insecure argocd-server.argocd.svc --username admin --password "$$(kubectl --context argocd get -o json secret argocd-initial-admin-secret | jq -r '.data.password | @base64d')" \
					&& argocd account update-password --new-password adminadmin --current-password "$$(kubectl --context argocd get -o json secret argocd-initial-admin-secret | jq -r '.data.password | @base64d')"); \
		fi; fi

git-crypt-unlock:
	cd ~/.password-store && if ! git crypt unlock; then \
		gpg -d .git-crypt-key > key; \
		git crypt unlock key; \
		rm -f key; \
		fi

kubeconfig:
	-sudo cp /run/secrets/kubernetes.io/serviceaccount/ca.crt /usr/local/share/ca-certificates/
	sudo cp ~/etc/ca.crt /usr/local/share/ca-certificates/
	sudo update-ca-certificates
	if test -f /run/secrets/kubernetes.io/serviceaccount/ca.crt; then \
		kubectl config set-cluster k3d-control --server=https://kubernetes.default.svc.cluster.local --embed-certs --certificate-authority=/run/secrets/kubernetes.io/serviceaccount/ca.crt; \
		kubectl config set-credentials k3d-control --token="$$(cat /run/secrets/kubernetes.io/serviceaccount/token)"; \
		kubectl config set-context k3d-control --cluster=k3d-control --user=k3d-control; \
		if control get ns argocd; then \
			kubectl config set-cluster argocd --server=https://kubernetes.default.svc.cluster.local --embed-certs --certificate-authority=/run/secrets/kubernetes.io/serviceaccount/ca.crt; \
			kubectl config set-credentials argocd --token="$$(cat /run/secrets/kubernetes.io/serviceaccount/token)"; \
			kubectl config set-context argocd --cluster=k3d-control --user=argocd --namespace argocd; \
			fi; \
		fi
	touch ~/.kube/config
	$(MAKE) perms
	if docker --context=host ps 2>/dev/null; then env DOCKER_CONTEXT=host k3d kubeconfig merge -d $$(k3d cluster list --no-headers | grep -v ^control | awk '{print $$1}'); fi
	-kubectl config use-context k3d-control
	k config get-contexts

pending-images:
	(control get pods --all-namespaces -o json | gron | grep '\.image ='  | cut -d'"' -f2 | grep -v 169.2543.32.1:5000/ | grep -v /defn/dev: | grep -v /workspace:latest) | sed 's#@.*##' | grep -v ^sha256 | sort -u > .image-versions.txt

sync: # Sync all the artifacts
	$(MAKE) pull-repos
	-$(MAKE) registry
	$(MAKE) sync-images

sync-images: # Sync images to local cache
	cat .image-versions.txt | bin/runmany 4 'skopeo copy docker://$$1 docker://127.0.0.1:5000/$${1#*/} --multi-arch all --dest-tls-verify=false'

cluster:
	cd d/k3d && $(MAKE) build name=$(context) app=$(app)
	@$(MAKE) $@-inner name=$(name)

cluster-inner:
	-k3d cluster delete $(name)
	@k3d cluster create $(name) \
		--k3s-node-label env=$(name)@server:0 \
		--config etc/k3d.yaml \
		--registry-config etc/k3d-registries.yaml $(DEFN_DEV_HOST_PORTMAPS) \
		--env bar=baz@server:0
	docker --context=host update --restart=no $(context)-server-0

vault-unseal:
	pass Unseal_Key_1 | curl -sSL -X PUT -d @<(jq -nrR 'inputs|{key:.}|@json') http://localhost:8200/v1/sys/unseal
	pass Unseal_Key_3 | curl -sSL -X PUT -d @<(jq -nrR 'inputs|{key:.}|@json') http://localhost:8200/v1/sys/unseal
	pass Unseal_Key_5 | curl -sSL -X PUT -d @<(jq -nrR 'inputs|{key:.}|@json') http://localhost:8200/v1/sys/unseal

vault-seal:
	-env VAULT_TOKEN="$$(pass Initial_Root_Token)" VAULT_ADDR=http://localhost:8200 vault operator seal
	rm -f ~/.vault-token
	cd ~/.password-store && git add vault && git add -u vault && git stash

vault-backup:
	$(MAKE) vault-seal
	cd .password-store && git stash apply && git add vault && git add -u vault && git commit -m "backup vault"
	cd .password-store && git push && git status -sb
	$(MAKE) vault-unseal

vault-trust:
	#-vault auth enable -path "$(k)" kubernetes

	vault write "auth/$(k)/config" \
		kubernetes_host="$$(kubectl config view -o jsonpath='{.clusters[?(@.name == "$(k)")]}' --raw | jq -r '.cluster.server')" \
		kubernetes_ca_cert=@<(kubectl config view -o jsonpath='{.clusters[?(@.name == "$(k)")]}' --raw | jq -r '.cluster["certificate-authority-data"] | @base64d') \
		disable_local_ca_jwt=true

	vault write "auth/$(k)/role/dev" \
		bound_service_account_names=default \
		bound_service_account_namespaces=default \
		policies=dev ttl=1h

	vault write "auth/$(k)/role/external-secrets" \
		bound_service_account_names=external-secrets \
		bound_service_account_namespaces=external-secrets \
		policies=external-secrets ttl=1h

vault-shell:
	@env VAULT_ADDR="http://localhost:8200" VAULT_TOKEN="$$(pass Initial_Root_Token)" bash

vault-test:
	@"$(context)" exec -ti -c code-server $(pod) -- bash -c 'env VAULT_ADDR=http://$(tailscale ip -4):8200 ~/bin/e vault write -field=token "auth/$(k)/login" role=default jwt=$$(cat /run/secrets/kubernetes.io/serviceaccount/token)'

vault-login:
	@vault login token="$$(vault write -field=token "auth/k3d-control/login" role=default jwt=$$(cat /run/secrets/kubernetes.io/serviceaccount/token))"

rebuild:
	$(MAKE) build
	ctr -n k8s.io i pull --plain-http ghcr.io/defn/dev:latest-dev
	ctr -n k8s.io i pull --plain-http 169.254.32.1:5000/workspace:latest

shell:
	docker run --rm -ti $(repo)defn/dev:latest-dev bash -l

debug-host:
	control debug "node/$$(control get nodes --no-headers | awk '{print $$1}' | fzf)" --image ghcr.io/defn/dev:latest-dev -it -- bash

debug:
	control debug -n "$(n)" "$(pod)" --image ghcr.io/defn/dev:latest-dev -it -- bash

this:
	rm -rf tmp
	mkdir tmp
	mkdir -p tmp/$(name)/var/lib/tailscale
	mkdir -p tmp/$(name)/var/lib/tailscale/pod
	mkdir -p tmp/$(name)/var/lib/rancher/k3s/server/tls
	(cd tmp/$(name) && pass tailscale_k3d-$(name) | base64 -d | tar xvf -)
	(cd tmp/$(name)/var/lib/tailscale/pod && pass tailscale_$(name)-0 | base64 -d | tar xvf -)
	for a in sa-signer.key sa-signer.key.pub sa-signer-pkcs8.pub; do (cd tmp/$(name)/var/lib/rancher/k3s/server/tls && pass piw-$(name)-$$a | base64 -d > $$a); done
	env DEFN_DEV_ARCHIVE="$$(cd tmp/$(name) && tar cvf - . | base64 | xargs | sed 's# ##g')" \
		$(MAKE) cluster name=$(name)

registry:
	-k3d registry create registry --port 0.0.0.0:5000
	#control apply -f etc/local-registry-hosting.yaml

pull-repos: # Pull dev, app, home, and password-store repos
	for a in . .dotfiles .password-store; do (echo; echo "$$a"; cd "$$a" && git pull) || true; done

global: # Provision global from control plane
	env DEFN_DEV_HOST_PORT=6444 DEFN_DEV_HOST_API=host.docker.internal \
		DEFN_DEV_NAME=k3d-$@ \
		DOCKER_CONTEXT=host \
		$(MAKE) this name=$@

vc%:
	$(MAKE) control-$@

control-%:
	$(MAKE) ec2
	kustomize build --enable-helm ~/work/app/k/$@ | $(first) apply -f -
	while ! $(first) -n $@ get secrets vc-vcluster >/dev/null; do sleep 10; done
	$(MAKE) connect_$@
	while ! $@ get -n kube-system pods >/dev/null; do sleep 1; done
	argocd cluster add vcluster-$@ --yes --upsert
	$(first) apply -f app/e/vcluster-$@.yaml

connect_%:
	$(shell echo $(second_) | cut -d- -f1) -n $(second_) get secrets vc-vcluster -o json | jq -r '.data.config | @base64d' | yq '.clusters[].cluster.server |= "https://vcluster.$(second_).svc.cluster.local" | del(.["current-context"])' -y | sed 's#my-vcluster#vcluster-$(second_)#' > ~/.kube/$(second_)
	env KUBECONFIG=~/.kube/$(second_):~/.kube/config kubectl config view --flatten > ~/.kube/config.$(second_)
	mv ~/.kube/config.$(second_) ~/.kube/config

ec2:
	pass hello
	@cat etc/ec2-user-data.template \
		| sed 's#_CONTROLIP_#'$$(host k3d-control.$$(wait-tailscale-domain | cut -d. -f2-) | awk '{print $$NF}')'#' \
		| sed 's#_TSKEY_#'$$(pass k3d-control-tskey)'#' \
		| sed 's#_K3STOKEN_#'$$(docker --context host exec k3d-control-server-0 cat /var/lib/rancher/k3s/server/node-token)'#' \
		| control apply -f -

debug-node:
	control debug node/$(node) -it --image=ghcr.io/defn/dev:latest-dev -- bash -il

debug-docker:
	docker run -it --rm --privileged --pid=host alpine:edge nsenter -t 1 -m -u -n -i

nix:
	if ! type -P nix; then . ~/.nix-profile/etc/profile.d/nix.sh; fi && $(MAKE) nix-$(shell uname -s)

nix-Linux-bootstrap:
	sh <(curl -L https://nixos.org/nix/install) --no-daemon

nix-Darwin-bootstrap:
	sh <(curl -L https://nixos.org/nix/install) --darwin-use-unencrypted-nix-store-volume --daemon

nix-reinstall:
	nix profile list | tail -n +2 | awk '{print $$NF}' | xargs nix profile remove
	$(MAKE) nix

nix-gc:
	nix-store --gc

nix-Linux:
	export LC_ALL=C.UTF-8 && if ! test -x ~/.nix-profile/bin/nix; then $(MAKE) nix-Linux-bootstrap; fi
	if test "$(shell which direnv pinentry nixpkgs-fmt | wc -l)" != "3"; then export LC_ALL=C.UTF-8 && nix profile install nixpkgs\#{nix-direnv,pinentry,nixpkgs-fmt}; fi

nix-Darwin:
	if test "$(shell which direnv pinentry nixpkgs-fmt | wc -l)" != "3"; then export LC_ALL=C.UTF-8 && nix profile install nixpkgs\#{nix-direnv,pinentry,nixpkgs-fmt}; fi
	sudo ln -nfs $(shell which pinentry-mac) .nix-profile/bin/pinentry

prune:
	-docker images | grep :5000/ | grep -E 'weeks|days' | awk '{print $$1 ":" $$2}' | runmany 'docker rmi $$1'
	-docker system prune -f
	-earthly prune

wg-up:
	pass wg_client | base64 -d | sudo tee /etc/wireguard/wg0.conf > /dev/null
	sudo wg-quick up wg0
	$(MAKE) wg-up-inner

wg-up-inner:
	dig @$(shell sudo cat /etc/wireguard/wg0.conf | grep AllowedIPs | awk '{print $$3}' | cut -d/ -f1)3 +noall +answer _apps.internal txt

wg-down:
	sudo wg-quick down wg0nix-bootstrap:

dev:
	docker pull ghcr.io/defn/dev:latest-devcontainer
	code --folder-uri "vscode-remote://dev-container+$$(pwd | perl -pe 's{\s+}{}g' | xxd -p)/home/ubuntu"
